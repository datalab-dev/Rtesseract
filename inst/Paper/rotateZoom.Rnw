
In Figure~\ref{fig:base} we can visually identify the rotated, vertical text on the right of the page.
In the examples above, we also encountered this text from the low confidence levels of the 
results returned from \code{GetBoxes()}.
Tesseract recognizes the rest of the page as horizontally oriented text
and is entirely confused by these symbols in that context.
So it returns nonsensical results. While we decided this text could safely
ignored in this case, in many cases we may want to extract the rotated text.
Ignoring how we identify the relevant rectangle(s) of interest 
in the page, we can

\begin{enumerate}
\item{rotate the contents image}
\item{restrict tesseract to separately recognize the text within each of these rectangles}
\end{enumerate} 

We start by reading the image. Rather than passing the name of the
file to \code{tesseract()}, we explicitly read the image
using \code{pixRead()}.

<<>>=
px = pixRead(smithburn)
@ 

Next we rotate this image 90 degrees, corresponding to a negative direction, or anticlockwise:
% for now, use pixRotateAMGray
<<>>=
prot = pixRotate(px, -pi/2)
@ 

We pass this rotated image to \code{tesseract()} rather than the name of a file:

<<>>=
ts = tesseract(prot)

@

We don't want to process all of the text in the image.
Instead, we want to zoom in on the now horizontal text.
As we illustrated above, we can plot the rotated image and see the
range of the horizontal and vertical region of interest:


Judging from the plot, we count from the top-down, starting at position 1000 (corresponding to 5000 on the plot)
and use a rectangle that is 300 pixels tall.
On the horizontal dimension, we could use the entire width of the image,
but we restrict the region to be between 500 and 3500.
As before, we instruct tesseract to only process this rectangle via \code{SetRectangle}:

<<>>=
SetRectangle(ts, dims = c(500, 1000, 3000, 300))
@ 

Finally, we perform the OCR and get the results using 

<<>>=
bb = GetBoxes(ts)
@ 

The results are

<<echo = FALSE>>=
bb
@ 

We have recovered the rotated text reasonably well, and significantly better
than how it was  identified in the original processing.
A ``w'' has been mistaken as a ``W'', the ``01'' at the end of \code{jimmun} in row 3 should be ``0l''.
But these are common mistakes.

\subsubsection{Transposing versus Rotating the Image}

% Separate

Rotating the image doesn't change the dimensions the image.
It moves the pixels to a different orientation.
However, we may want to actually transpose the image, i.e., change the
horizontal to vertical and vice versa and so change the dimensions
of an r by c image to c by r.
We can do this in two steps by
the pixels from one Pix object to an R array and then back to an other existing
Pix object.
The function pixTranspose() does this

<<>>=
pt = pixTranspose(px)
plot(pt)
@ 

Now we don't have the large black regions and the dimension of the image
is 4050 rows by 60000 columns.

We can have tesseract process the sub-rectangle

<<>>=
ts = tesseract(pt)
SetRectangle(ts, dims = c(1500, 50, 3000, 300))
bb = GetBoxes(ts)
bb
@
 
We get very slightly different answers (WWW rather than Www and 
different confidences) but they are qualitatively the same.
This approach is somewhat simpler conceptual, but it is slower
as currently, transposing an image is quite slow.
This is because it extracts all of the pixels from the original image, creates a new image (fast)
and copies all of the pixels to the new image in the appropriate transposed order.
We will make this faster in the future using more efficient elements of the leptonica API
to get and set pixels.
